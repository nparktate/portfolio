---
---

<div class="eyeball-container" id="eyeball-container">
  <div class="eyeball" id="eyeball">
    <div class="veins"></div>
    <div class="sclera"></div>
    <div class="pupil" id="pupil"></div>
  </div>
</div>

<script is:inline>
  document.addEventListener('DOMContentLoaded', () => {
    const pupil = document.getElementById('pupil');
    const eyeball = document.getElementById('eyeball');
    const eyeballContainer = document.getElementById('eyeball-container');
    
    if (pupil && eyeball && eyeballContainer) {
      // Set initial position randomly on screen
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      const initialX = Math.random() * (screenWidth - 200) + 100;
      const initialY = Math.random() * (screenHeight - 200) + 100;
      
      // Initialize position
      eyeballContainer.style.top = initialY + 'px';
      eyeballContainer.style.left = initialX + 'px';
      
      // Variables for movement
      let targetX = initialX;
      let targetY = initialY;
      let currentX = initialX;
      let currentY = initialY;
      let lastMoveTime = 0;
      let lastPointerX = initialX;
      let lastPointerY = initialY;
      let ambientPhase = 0;
      let isMobile = false;
      
      // Fear level tracking variables
      let fearLevel = 0; // 0=normal, 1=nervous, 2=anxious, 3=scared, 4=terrified, 5=agony
      let avoidanceFactor = 0; // Increases with fear level
      let lastCursorDistance = 0;
      
      // Check if device is mobile
      isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      
      // Constants - adjusted for mobile experience with more movement
      const moveSpeed = isMobile ? 0.15 : 0.08; // Faster movement on mobile
      const repositionChance = isMobile ? 0.02 : 0.005; // Higher chance of repositioning on mobile
      const edgeBuffer = 50;
      const ambientSpeed = isMobile ? 0.008 : 0.003; // Significantly increased for mobile
      const ambientRadius = isMobile ? 25 : 8; // Much larger ambient movement on mobile
      const fearThreshold = isMobile ? 200 : 300; // Reduced threshold on mobile
      
      // Size configuration for random sizing
      const sizesRange = {
        min: 30,
        max: 60,
        default: 40
      };
      let currentSize = sizesRange.default;
      
      // Click counter for easter egg
      let clickCount = 0;
      let agonyTimeout = null;
      
      // Function to set a random size
      function setRandomSize() {
        // Generate random size within range
        currentSize = Math.floor(Math.random() * (sizesRange.max - sizesRange.min + 1)) + sizesRange.min;
        eyeballContainer.style.width = `${currentSize}px`;
        eyeballContainer.style.height = `${currentSize}px`;
      }
      
      // Function to update pupil position
      function updatePupilPosition(pointerX, pointerY) {
        lastPointerX = pointerX;
        lastPointerY = pointerY;
        lastMoveTime = Date.now(); // Update last movement time
        
        // Update pupil position to follow pointer
        const eyeRect = eyeball.getBoundingClientRect();
        const eyeCenterX = eyeRect.left + eyeRect.width / 2;
        const eyeCenterY = eyeRect.top + eyeRect.height / 2;
        
        const deltaX = pointerX - eyeCenterX;
        const deltaY = pointerY - eyeCenterY;
        
        // Calculate angle and distance
        const angle = Math.atan2(deltaY, deltaX);
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        lastCursorDistance = distance;
        
        // Update fear response based on cursor proximity - simplified for mobile
        if (fearLevel > 0 && distance < fearThreshold) {
          // Apply fear behaviors based on level and device
          if (fearLevel >= 2 && !isMobile) {
            // Level 2+: Try to move away from cursor (desktop only)
            const avoidAngle = angle + Math.PI; // Opposite direction
            const avoidFactor = (fearLevel * 0.5) * (1 - Math.min(1, distance / fearThreshold));
            const avoidX = Math.cos(avoidAngle) * (100 * avoidFactor);
            const avoidY = Math.sin(avoidAngle) * (100 * avoidFactor);
            
            targetX += avoidX;
            targetY += avoidY;
            
            // Keep within screen bounds
            targetX = Math.max(50, Math.min(window.innerWidth - 50, targetX));
            targetY = Math.max(50, Math.min(window.innerHeight - 50, targetY));
            
            lastMoveTime = Date.now();
          } else if (fearLevel >= 2 && isMobile) {
            // On mobile, just make random movements instead of cursor avoidance
            if (Math.random() < 0.3) {  // 30% chance of random movement
              const jitterAmount = 50 * fearLevel;
              targetX += (Math.random() * jitterAmount * 2) - jitterAmount;
              targetY += (Math.random() * jitterAmount * 2) - jitterAmount;
              
              // Keep within screen bounds
              targetX = Math.max(50, Math.min(window.innerWidth - 50, targetX));
              targetY = Math.max(50, Math.min(window.innerHeight - 50, targetY));
              
              lastMoveTime = Date.now();
            }
          }
          
          // Visual fear response - works on both mobile and desktop
          if (fearLevel >= 1) {
            // Add increasing jitter to the eyeball
            eyeball.style.setProperty('--jitter-intensity', fearLevel);
            
            if (!eyeball.classList.contains('jittering')) {
              eyeball.classList.add('jittering');
              setTimeout(() => {
                eyeball.classList.remove('jittering');
              }, 300);
            }
          }
        }
        
        // Determine pupil size based on distance and fear level
        const closeThreshold = 150; // Distance at which pupil begins to constrict
        let pupilScale = 1.0;
        
        if (distance < closeThreshold) {
          // Pupil gets smaller as cursor gets closer
          const constrictionFactor = Math.max(0.4, distance / closeThreshold);
          pupilScale = constrictionFactor;
          
          // Fear level affects pupil more dramatically
          if (fearLevel >= 3) {
            // More extreme pupil response for higher fear levels
            pupilScale = Math.max(0.3, pupilScale - (fearLevel * 0.05));
          }
        } else if (fearLevel >= 4) {
          // Terrified - rapidly dilating pupil
          pupilScale = 1.2 + Math.sin(Date.now() * 0.01) * 0.3;
        } else if (isMobile && Date.now() - lastMoveTime > 3000) {
          // On mobile when idle, have an enormously larger pupil size
        pupilScale = 2.2 + Math.sin(Date.now() * 0.001) * 0.4; // Gentle breathing effect with enormous base size
        }
        
        // Move pupil based on pointer position - preventing clipping outside the eye
        // Calculate maximum safe radius based on pupil size to prevent clipping
        const pupilSize = pupil.offsetWidth;
        const eyeRadius = eyeRect.width / 2;
        const safeRadius = Math.max(0, eyeRadius - (pupilSize / 2) - 2); // 2px buffer
        
        const pupilMaxRadius = safeRadius; // Using safe radius to prevent clipping
        const intensity = Math.min(1, distance / 300);
        const pupilRadius = pupilMaxRadius * intensity;
        const pupilX = Math.cos(angle) * pupilRadius;
        const pupilY = Math.sin(angle) * pupilRadius;
        
        // Apply pupil position and scale
        pupil.style.transform = `translate(calc(-50% + ${pupilX}px), calc(-50% + ${pupilY}px)) scale(${pupilScale})`;
        
        // Add redness effect when looking at extreme angles
        const extremeThreshold = 0.5; // How far from center (as a fraction of max) to start showing redness
        const extremeRatio = Math.max(0, (Math.abs(pupilRadius) / pupilMaxRadius) - extremeThreshold) / (1 - extremeThreshold);
        
        if (extremeRatio > 0) {
          // Calculate opposite direction from pupil position
          const oppositeAngle = angle + Math.PI;
          const redX = Math.cos(oppositeAngle);
          const redY = Math.sin(oppositeAngle);
          
          // Create gradient from transparent to red on the opposite side
          const gradientIntensity = Math.min(1, extremeRatio * 1.5);
          const redColor = `rgba(255, 0, 0, ${gradientIntensity * 0.5})`;
          
          // Apply the gradient to show "back of eye" redness
          eyeball.style.background = `radial-gradient(circle at calc(50% + ${redX * 40}%) calc(50% + ${redY * 40}%), ${redColor} 0%, transparent 70%), #fffdf0`;
        } else {
          // Reset background when not at extreme angle
          eyeball.style.background = "";
        }
        
        // Randomly reposition the eyeball occasionally - less likely when afraid
        const fearAdjustedChance = Math.max(0, repositionChance - (fearLevel * 0.001));
        if (Math.random() < fearAdjustedChance && Date.now() - lastMoveTime > 2000) {
          // Choose a new random position
          const screenWidth = window.innerWidth;
          const screenHeight = window.innerHeight;
          
          targetX = Math.random() * (screenWidth - 100) + 50;
          targetY = Math.random() * (screenHeight - 100) + 50;
          
          lastMoveTime = Date.now();
        }
      }
      
      // Track mouse movement
      document.addEventListener('mousemove', (e) => {
        updatePupilPosition(e.clientX, e.clientY);

      });
      
      // Track touch movement for mobile - simplified to avoid scroll interference
      document.addEventListener('touchmove', (e) => {
        if (e.touches && e.touches[0] && e.target === eyeballContainer) {
          updatePupilPosition(e.touches[0].clientX, e.touches[0].clientY);
          e.preventDefault(); // Only prevent scrolling when touching the eyeball
        }
      });
      
      // Initial touch position
      document.addEventListener('touchstart', (e) => {
        if (e.touches && e.touches[0]) {
          // Only update if touching the eyeball itself
          if (e.target === eyeballContainer || e.target === eyeball || eyeballContainer.contains(e.target)) {
            updatePupilPosition(e.touches[0].clientX, e.touches[0].clientY);
          }
        }
      });
      
      // Random movement for mobile when not interacting
      let mobileMovementInterval = null;
      let idlePupilInterval = null;
      
      if (isMobile) {
        // Set up more frequent, noticeable random movement on mobile
        mobileMovementInterval = setInterval(() => {
          // Only move randomly if not recently interacted with
          if (Date.now() - lastMoveTime > 3000) {
            // Random movement with larger range (30% of screen width)
            const moveRange = window.innerWidth * 0.3; 
            const newX = currentX + (Math.random() * moveRange * 2 - moveRange);
            const newY = currentY + (Math.random() * moveRange * 2 - moveRange);
            
            // Keep within screen bounds
            targetX = Math.max(50, Math.min(window.innerWidth - 50, newX));
            targetY = Math.max(50, Math.min(window.innerHeight - 50, newY));
            
            // Look around randomly with wider range
            const lookX = targetX + Math.random() * 200 - 100;
            const lookY = targetY + Math.random() * 200 - 100;
            updatePupilPosition(lookX, lookY);
          }
        }, 1500); // More frequent movements
        
        // Set up idle pupil animation to make it more lifelike
        idlePupilInterval = setInterval(() => {
          // Only adjust pupil if not recently interacted with
          if (Date.now() - lastMoveTime > 4000) {
            // Randomly adjust pupil size for more natural appearance - enormously larger on mobile
            const basePupilSize = 2.2 + (Math.random() * 0.6); // Between 2.2 and 2.8 - over 2x larger
            pupil.style.transform = pupil.style.transform.replace(/scale\([^)]+\)/, `scale(${basePupilSize})`);
            
            // Move pupil around randomly with dramatic movement but prevent clipping
            const eyeRect = eyeball.getBoundingClientRect();
            const eyeCenterX = eyeRect.left + eyeRect.width / 2;
            const eyeCenterY = eyeRect.top + eyeRect.height / 2;
            
            // Calculate safe radius based on pupil size to prevent clipping
            const pupilSize = pupil.offsetWidth;
            const eyeRadius = eyeRect.width / 2;
            const safeRadius = Math.max(0, eyeRadius - (pupilSize / 2) - 2); // 2px buffer
            
            // Random angle and radius within safe boundaries
            const randomAngle = Math.random() * Math.PI * 2;
            const randomRadius = Math.random() * safeRadius * 0.9; // Up to 90% of safe radius for dramatic edge effect
            const lookX = eyeCenterX + Math.cos(randomAngle) * randomRadius;
            const lookY = eyeCenterY + Math.sin(randomAngle) * randomRadius;
            updatePupilPosition(lookX, lookY);
            
            // Occasionally blink when idle
            if (Math.random() < 0.1) { // 10% chance each interval
              eyeball.classList.add('blinking');
              setTimeout(() => {
                eyeball.classList.remove('blinking');
              }, 200);
            }
          }
        }, 1000); // More frequent updates
      }
      
      // Animation loop to update eyeball position with ambient movement
      function updatePosition() {
        // Add subtle ambient movement - more erratic with higher fear
        ambientPhase += ambientSpeed * (1 + (fearLevel * 0.5));
        const fearFactor = Math.max(1, fearLevel);
        const ambientX = Math.sin(ambientPhase) * ambientRadius * fearFactor;
        const ambientY = Math.cos(ambientPhase * 1.3) * ambientRadius * fearFactor;
        
        // Move toward target position with easing - faster when afraid
        const fearAdjustedSpeed = moveSpeed * (1 + (fearLevel * 0.15));
        currentX += (targetX - currentX) * fearAdjustedSpeed;
        currentY += (targetY - currentY) * fearAdjustedSpeed;
        
        // Update container position with fear-affected ambient movement
        eyeballContainer.style.left = `${currentX + ambientX}px`;
        eyeballContainer.style.top = `${currentY + ambientY}px`;
        eyeballContainer.style.transition = 'none'; // Remove transition for smoother animation
        
        // Enhanced mobile behavior - more engaging eye movement when not interacting
        if (isMobile && Date.now() - lastMoveTime > 3000) {
            // Get eye center
            const eyeRect = eyeball.getBoundingClientRect();
            const eyeCenterX = eyeRect.left + eyeRect.width / 2;
            const eyeCenterY = eyeRect.top + eyeRect.height / 2;
          
            // Extremely pronounced looking around on mobile - dramatically wider range of movement
            const lookMagnitude = 55 + (Math.sin(Date.now() * 0.001) * 30);
          
            // Use multiple sine waves with different frequencies for more natural movement
            const lookX = eyeCenterX + Math.sin(ambientPhase * 1.2) * lookMagnitude + Math.cos(ambientPhase * 0.7) * (lookMagnitude * 0.8);
            const lookY = eyeCenterY + Math.cos(ambientPhase * 0.9) * lookMagnitude + Math.sin(ambientPhase * 1.3) * (lookMagnitude * 0.9);
          
            // Create a more active "wandering gaze" effect with positions up to the edge but not clipping
            if (Math.random() < 0.02) { // 2% chance per frame to pick a new spot to look at
              // Calculate safe radius based on pupil size to prevent clipping
              const pupilSize = pupil.offsetWidth;
              const eyeRadius = eyeRect.width / 2;
              const safeRadius = Math.max(0, eyeRadius - (pupilSize / 2) - 2); // 2px buffer
              
              // Random angle with radius up to the safe limit
              const wanderAngle = Math.random() * Math.PI * 2;
              const wanderRadius = Math.random() * safeRadius;
              const wanderX = eyeCenterX + Math.cos(wanderAngle) * wanderRadius;
              const wanderY = eyeCenterY + Math.sin(wanderAngle) * wanderRadius;
              updatePupilPosition(wanderX, wanderY);
            } else {
              updatePupilPosition(lookX, lookY);
            }
          }
        
        requestAnimationFrame(updatePosition);
      }
      
      // Start position animation
      updatePosition();
      
      // Simple blinking function
      function blink() {
        eyeball.classList.add('blinking');
        
        setTimeout(() => {
          eyeball.classList.remove('blinking');
        }, 200);
        
        // Schedule next blink
        setTimeout(blink, 3000 + Math.random() * 4000);
      }
      
      // Start blinking
      setTimeout(blink, 1000);
      
      // Add click/touch event to change size and position - enhanced for mobile
      eyeballContainer.addEventListener(isMobile ? 'touchend' : 'click', (e) => {
        // Prevent default behavior for touch events
        if (e.type === 'touchend') {
          e.preventDefault();
        }
        
        // Update last interaction time
        lastMoveTime = Date.now();
        
        // Increment click counter
        clickCount++;
        
        // Update fear level based on click count (1-4 for fear stages, 5 for agony)
        fearLevel = clickCount;
        
        // Apply appropriate fear class based on level
        eyeball.classList.remove('nervous', 'anxious', 'scared', 'terrified');
        
        // Fear response gets more dramatic with each click
        
        // Check for agony easter egg
        if (clickCount === 5) {
          // Trigger agony animation
          eyeball.classList.add('agony');
          
          // Play agony sound
          const agonyAudio = new Audio();
          agonyAudio.volume = 0.25; // Slightly louder
          agonyAudio.src = "data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+M4wAAAAAAAAAAAAEluZm8AAAAPAAAAEwAAAHwAVVVVVVVVVVVVVVVVVVVVgICAgICAgICAgICAgICAgICqqqqqqqqqqqqqqqqqqqqqwMDAwMDAwMDAwMDAwMDAwMDV1dXV1dXV1dXV1dXV1dXV4ODg4ODg4ODg4ODg4ODg4OD/////////////////////////////////AAAAAExhdmM1OC4xMwAAAAAAAAAAAAAAACQEOAAAAAAAAAB8nx5ywQAAAAAAAAAAAAAAAAAAAAAA";
          agonyAudio.play().catch(e => console.log("Audio play prevented: ", e));
    
          // No text element, just audio and visual effects
          
          // Reset after agony animation completes
          if (agonyTimeout) {
            clearTimeout(agonyTimeout);
          }
    
          // Add intense shaking to container during agony
          eyeballContainer.style.animation = "shake 0.1s infinite";
    
          // Erratic movement during agony
          const agonyMovement = setInterval(() => {
            const jitterX = Math.random() * 20 - 10;
            const jitterY = Math.random() * 20 - 10;
      
            currentX += jitterX;
            currentY += jitterY;
      
            // Keep within screen bounds
            currentX = Math.max(50, Math.min(window.innerWidth - 50, currentX));
            currentY = Math.max(50, Math.min(window.innerHeight - 50, currentY));
          }, 150);
    
          agonyTimeout = setTimeout(() => {
            // Reset all fear-related classes
            eyeball.classList.remove('agony', 'nervous', 'anxious', 'scared', 'terrified');
            
            // Reset all styles
            eyeballContainer.style.animation = "";
            eyeball.style.backgroundColor = "#fffdf0"; // Original color
            eyeball.style.boxShadow = "";
            
            // Reset veins
            const veins = eyeball.querySelector('.veins');
            if (veins) {
              veins.style.opacity = '0.18'; // Original opacity
              veins.style.background = '';
              veins.style.backgroundImage = '';
              veins.style.animation = '';
            }
            
            // Reset counters
            clickCount = 0;
            fearLevel = 0;
            
            // Clear intervals
            clearInterval(agonyMovement);
            
            // On mobile, trigger random movement after reset
            if (isMobile) {
              setTimeout(() => {
                // Move to a random position after recovering
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                targetX = Math.random() * (screenWidth - 100) + 50;
                targetY = Math.random() * (screenHeight - 100) + 50;
              }, 500);
            }
          }, isMobile ? 4000 : 5000); // Slightly shorter duration on mobile
          
          return; // Skip normal click behavior
        } else if (clickCount === 1) {
          // First click - becoming nervous
          eyeball.classList.add('nervous');
          
          // Play subtle nervous sound
          const nervousAudio = new Audio();
          nervousAudio.volume = 0.1;
          nervousAudio.src = "data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+M4wAAAAAAAAAAAAEluZm8AAAAPAAAAAwAAAbAAkJCQkJCQkJCQkJCQkJCQwMDAwMDAwMDAwMDAwMDAwMD/////////////////////////////////AAAAAExhdmM1OC4xMwAAAAAAAAAAAAAAACQCkAAAAAAAAAGwuTR9zgAAAAAAAAAAAAAAAAAAAAAA";
          nervousAudio.play().catch(e => console.log("Audio play prevented: ", e));
          
          // Subtle color change
          eyeball.style.backgroundColor = '#fffbe8';
        } else if (clickCount === 2) {
          // Second click - becoming anxious
          eyeball.classList.add('anxious');
          
          // Slightly yellowish tint
          eyeball.style.backgroundColor = '#fff8d9';
          
          // Increase veins visibility
          const veins = eyeball.querySelector('.veins');
          if (veins) veins.style.opacity = '0.25';
        } else if (clickCount === 3) {
          // Third click - becoming scared
          eyeball.classList.add('scared');
          
          // More pronounced color change
          eyeball.style.backgroundColor = '#fff5cc';
          
          // Further increase veins
          const veins = eyeball.querySelector('.veins');
          if (veins) {
            veins.style.opacity = '0.35';
            veins.style.background = 'radial-gradient(circle, transparent 60%, #ff4500 100%)';
          }
        } else if (clickCount === 4) {
          // Fourth click - becoming terrified
          eyeball.classList.add('terrified');
          
          // Bloodshot look
          eyeball.style.backgroundColor = '#fff0bf';
          
          // Dramatic veins
          const veins = eyeball.querySelector('.veins');
          if (veins) {
            veins.style.opacity = '0.5';
            veins.style.background = 'radial-gradient(circle, transparent 55%, #ff0000 100%)';
          }
          
          // Play terrified sound
          const scaredAudio = new Audio();
          scaredAudio.volume = 0.15;
          scaredAudio.src = "data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+M4wAAAAAAAAAAAAEluZm8AAAAPAAAABAAAAVAAICAgICAgICAgICAgIEBAQEBAQEBAQEBAQEBAYGBgYGBgYGBgYGBgYGBggICAgICAgICAgICAgICA/////////////////////////////////AAAAAExhdmM1OC4xMwAAAAAAAAAAAAAAACQDUAAAAAAAAAFQEbBGTQAAAAAAAAAAAAAAAAAAAAAA";
          scaredAudio.play().catch(e => console.log("Audio play prevented: ", e));
        }
        
        // Normal click behavior (only if not triggering agony)
        // Change to a random size - smaller when afraid
        setRandomSize();
        
        // Move to a random position on screen
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        
        targetX = Math.random() * (screenWidth - 100) + 50;
        targetY = Math.random() * (screenHeight - 100) + 50;
        
        // Add animation to eyeball on click
        eyeball.classList.add('size-changing');
        
        // Play subtle click sound
        const audio = new Audio();
        audio.volume = 0.1;
        audio.src = "data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+M4wAAAAAAAAAAAAEluZm8AAAAPAAAAAwAAAbAAkJCQkJCQkJCQkJCQkJCQwMDAwMDAwMDAwMDAwMDAwMD/////////////////////////////////AAAAAExhdmM1OC4xMwAAAAAAAAAAAAAAACQCkAAAAAAAAAGwuTR9zgAAAAAAAAAAAAAAAAAAAAAA";
        audio.play().catch(e => console.log("Audio play prevented: ", e));
        
        setTimeout(() => {
          eyeball.classList.remove('size-changing');
        }, 500);
      });
      
      // Make the eyeball appear clickable
      eyeballContainer.style.cursor = 'pointer';
      // Remove pointer-events: none to allow clicks
      eyeballContainer.style.pointerEvents = 'auto';
    }
  });
</script>

<style>
  /* Size changing animation */
  .eyeball.size-changing {
    animation: bounce 0.5s ease-out;
  }
  
  @keyframes bounce {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    75% { transform: scale(0.9); }
    100% { transform: scale(1); }
  }
  
  @keyframes shake {
    0% { transform: translate(0, 0) rotate(0deg); }
    25% { transform: translate(-4px, 3px) rotate(-5deg); }
    50% { transform: translate(5px, -2px) rotate(5deg); }
    75% { transform: translate(-3px, -5px) rotate(-3deg); }
    100% { transform: translate(4px, 4px) rotate(4deg); }
  }
  
  /* Fear state animations - each stage more distinct */
  .eyeball.nervous {
    animation: nervousJitter 2s infinite;
    transition: all 0.3s ease;
  }
  
  .eyeball.anxious {
    animation: anxiousShake 1s infinite;
    box-shadow: 0 0 8px rgba(255, 200, 0, 0.2);
    transition: all 0.3s ease;
  }
  
  .eyeball.scared {
    animation: scaredPulse 0.7s infinite alternate;
    box-shadow: 0 0 12px rgba(255, 150, 0, 0.3);
    transition: all 0.3s ease;
  }
  
  .eyeball.terrified {
    animation: terrifiedShake 0.3s infinite;
    box-shadow: 0 0 15px rgba(255, 80, 0, 0.4);
    transition: all 0.3s ease;
  }
  
  @keyframes nervousJitter {
    0%, 100% { transform: translate(0, 0); }
    25% { transform: translate(-1px, 1px); }
    50% { transform: translate(1px, -1px); }
    75% { transform: translate(-1px, -1px); }
  }
  
  @keyframes anxiousShake {
    0%, 100% { transform: translate(0, 0) rotate(0deg); }
    25% { transform: translate(-2px, 1px) rotate(-1deg); }
    50% { transform: translate(2px, -1px) rotate(1deg); }
    75% { transform: translate(-2px, -1px) rotate(-1deg); }
  }
  
  @keyframes scaredPulse {
    0% { transform: scale(1); filter: brightness(1.01); }
    100% { transform: scale(1.05); filter: brightness(1.05); }
  }
  
  @keyframes terrifiedShake {
    0% { transform: translate(0, 0) rotate(0deg) scale(1.02); }
    25% { transform: translate(-3px, 2px) rotate(-2deg) scale(0.98); }
    50% { transform: translate(3px, -2px) rotate(2deg) scale(1.03); }
    75% { transform: translate(-3px, -2px) rotate(-2deg) scale(0.97); }
    100% { transform: translate(3px, 2px) rotate(2deg) scale(1.02); }
  }
  
  /* Agony animation */
  .eyeball.agony {
    animation: writhe 0.15s infinite alternate ease-in-out;
    box-shadow: 0 0 20px 5px rgba(255, 0, 0, 0.7);
  }

  .eyeball.agony .pupil {
    animation: dilate 0.1s infinite alternate ease-in-out;
    background-color: #ff3333 !important;
    box-shadow: 0 0 10px 3px rgba(255, 0, 0, 0.8) inset;
  }

  .eyeball.agony .veins {
    opacity: 0.6;
    animation: pulsate 0.3s infinite alternate;
    background-image: 
      radial-gradient(circle, transparent 55%, #ff0000 100%),
      linear-gradient(30deg, transparent 45%, rgba(255,0,0,0.4) 50%, transparent 55%),
      linear-gradient(90deg, transparent 45%, rgba(255,0,0,0.4) 50%, transparent 55%),
      linear-gradient(150deg, transparent 45%, rgba(255,0,0,0.4) 50%, transparent 55%);
  }

  .eyeball.agony:before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle, rgba(255,0,0,0.4) 0%, transparent 70%);
    z-index: 2;
    animation: pulse 0.5s infinite alternate;
  }

  @keyframes writhe {
    0% { transform: scale(1.3) rotate(-20deg); filter: hue-rotate(0deg) contrast(1.5); }
    25% { transform: scale(0.8) rotate(25deg); filter: hue-rotate(45deg) contrast(1.2); }
    50% { transform: scale(1.4) rotate(-15deg); filter: hue-rotate(90deg) contrast(1.7); }
    75% { transform: scale(0.7) rotate(30deg); filter: hue-rotate(135deg) contrast(1.3); }
    100% { transform: scale(1.35) rotate(-25deg); filter: hue-rotate(180deg) contrast(1.6); }
  }

  @keyframes dilate {
    0% { transform: translate(-50%, -50%) scale(1.8); border-radius: 20%; }
    33% { transform: translate(-55%, -45%) scale(0.5); border-radius: 60%; }
    66% { transform: translate(-45%, -55%) scale(1.5); border-radius: 30%; }
    100% { transform: translate(-50%, -50%) scale(0.6); border-radius: 40%; }
  }

  @keyframes pulse {
    0% { opacity: 0.3; transform: scale(0.9); }
    100% { opacity: 0.7; transform: scale(1.1); }
  }

  @keyframes pulsate {
    0% { opacity: 0.4; }
    100% { opacity: 0.8; }
  }

  .eyeball-container {
    position: fixed;
    width: 40px;
    height: 40px;
    z-index: 100;
    pointer-events: auto; /* Allow clicking */
    cursor: pointer; /* Show it's clickable */
    will-change: left, top;
    transition: transform 0.2s ease;
    touch-action: none; /* Prevents browser handling of touch gestures */
  }
  
  .eyeball-container:hover {
    transform: scale(1.1);
  }
  
  .eyeball-container:active {
    transform: scale(0.95);
  }
  
  .eyeball {
    position: relative;
    width: 100%;
    height: 100%;
    background-color: #fffdf0;
    border-radius: 50%;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.15);
    overflow: hidden;
    transform-origin: center;
    transition: transform 0.1s ease-out, box-shadow 0.3s ease, background 0.2s ease-out;
  }
  
  .eyeball.jiggling {
    animation: jiggle 0.3s ease-in-out;
    animation-iteration-count: 1;
    --jiggle-intensity: 1;
  }
  
  /* Pupil states for different fear levels - more distinct */
  .eyeball.nervous .pupil {
    transition: transform 0.1s ease-out, scale 0.15s ease-out;
    background-color: #111; /* Slightly lighter than default */
  }
  
  .eyeball.anxious .pupil {
    transition: transform 0.08s ease-out, scale 0.1s ease-out;
    background-color: #000;
    animation: pupilDilate 1.5s infinite;
  }
  
  .eyeball.scared .pupil {
    transition: transform 0.05s ease-out, scale 0.08s ease-out;
    background-color: #000;
    animation: pupilPulse 0.5s infinite alternate;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3) inset;
  }
  
  .eyeball.terrified .pupil {
    transition: transform 0.03s linear, scale 0.05s linear;
    background-color: #000;
    animation: pupilTwitch 0.3s infinite alternate;
    box-shadow: 0 0 8px rgba(0, 0, 0, 0.5) inset;
  }
  
  @keyframes pupilDilate {
    0%, 100% { transform: translate(-50%, -50%) scale(0.9); }
    50% { transform: translate(-50%, -50%) scale(1.05); }
  }
  
  @keyframes pupilPulse {
    0% { transform: translate(-50%, -50%) scale(0.7); }
    100% { transform: translate(-50%, -50%) scale(1.2); }
  }
  
  @keyframes pupilTwitch {
    0% { transform: translate(calc(-50% - 3px), calc(-50% - 3px)) scale(0.6); }
    25% { transform: translate(calc(-50% + 4px), calc(-50% - 2px)) scale(1.3); }
    50% { transform: translate(calc(-50% - 2px), calc(-50% + 4px)) scale(0.8); }
    75% { transform: translate(calc(-50% + 3px), calc(-50% + 2px)) scale(1.4); }
    100% { transform: translate(calc(-50% - 4px), calc(-50% - 4px)) scale(0.7); }
  }
  
  .eyeball.blinking:before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    background-color: #fff;
    z-index: 5;
    animation: blink 0.2s ease-in-out;
  }
  
  .pupil {
  position: absolute;
  width: 48%;
  height: 48%;
  background-color: #000;
  border-radius: 50%;
  top: 50%;
  left: 50%;
    transform: translate(-50%, -50%) scale(2.0); /* Enormously larger pupil */
    transition: transform 0.08s ease-out, scale 0.15s ease-out;
    z-index: 3;
    will-change: transform;
  }
  
  .veins {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    opacity: 0.18;
    background: radial-gradient(circle, transparent 65%, #ff3000 100%);
    background-image: 
      radial-gradient(circle, transparent 65%, #ff3000 100%),
      linear-gradient(30deg, transparent 49.5%, rgba(255,0,0,0.1) 50%, transparent 50.5%),
      linear-gradient(90deg, transparent 49.5%, rgba(255,0,0,0.1) 50%, transparent 50.5%),
      linear-gradient(150deg, transparent 49.5%, rgba(255,0,0,0.1) 50%, transparent 50.5%);
    pointer-events: none;
    z-index: 1;
  }
  
  .sclera {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: 
      radial-gradient(circle at 30% 30%, rgba(255,255,255,0.5) 0%, transparent 30%),
      radial-gradient(circle at 70% 70%, rgba(255,255,240,0.5) 0%, transparent 20%);
    z-index: 2;
    pointer-events: none;
  }
  
  @keyframes quickBlink {
    0% { height: 0; top: 50%; opacity: 1; }
    50% { height: 100%; top: 0; opacity: 1; }
    100% { height: 0; top: 50%; opacity: 1; }
  }
  
  @keyframes jiggle {
    0% { transform: rotate(0deg) scale(1); }
    15% { transform: rotate(calc(var(--jiggle-intensity) * -4deg)) scale(calc(1 + var(--jiggle-intensity) * 0.05)); }
    32% { transform: rotate(calc(var(--jiggle-intensity) * 3deg)) scale(calc(1 - var(--jiggle-intensity) * 0.03)); }
    50% { transform: rotate(calc(var(--jiggle-intensity) * -2deg)) scale(calc(1 + var(--jiggle-intensity) * 0.02)); }
    65% { transform: rotate(calc(var(--jiggle-intensity) * 1deg)) scale(calc(1 - var(--jiggle-intensity) * 0.01)); }
    85% { transform: rotate(calc(var(--jiggle-intensity) * -0.5deg)) scale(1); }
    100% { transform: rotate(0deg) scale(1); }
  }
  

  
  /* Animation for pupil when scared */
  @keyframes blink {
    0%, 100% { height: 0%; top: 50%; }
    50% { height: 100%; top: 0%; }
  }

  @keyframes fadeOutUp {
    0% { opacity: 1; transform: translateY(0); }
    100% { opacity: 0; transform: translateY(-50px); }
  }
</style>